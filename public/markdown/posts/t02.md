## I/O 101

While making the backend for my portfolio on Deno I came across some input and output tasks, so I took that moment as an opportunity to hammer down a bit my understanding on how all of that worked by writting about it. This is the text.

### What is I/O (Input and Output):
Input and output both reffer to the direction of data comming from or out of your application. Input is used whenever your app takes in data from somewhere, output is used for whenever your app send data somewhere else.

On this doc Ill focus on I/O operations when dealing with files specifficaly. Ill try to expand it in the future with some Web Socket I/O.

You will also notice that this document doesn't talk about API speciffics. It just talks about how generally things work, but we wont adhere to any language's syntax.

### I/O entities

- **Input devices** are those that allow us to get data from them. Good examples are a Keyboard, a mouse or a mic.
These devices are usually characterized by the fact that they are specialized on transmutating data, usually from the pysical medium onto the digital one (a mic records, etc) and then send it somewhere for further processing. This is important to know because it informs you about the nature of the data you are accessing (live data)

- **Output devices** are those where you usually just send data to, like a monitor or speakers.
These devices are usually characterized by the fact that they are consumers of the data they receive. They dont store it, but rather they make instant use of it.

- **Input AND output entities:** These are more complex entities like a File, a web socket, or even your computer's Heap (Im keeping the naming to the software counterparts here because it feels more natural)

That being said, lets walk trough the process of obtaining data from a file on the hard disk; an input operation.

## Getting data from a file

When we want to get data from a file on our HDD/SDD, we start by creating a "data stream" object. This data stream instance serves as a link from the file in the HDD/SSD to our application. This stream will deliver the data to us when we ask for it, which at first glance it seems weird, why do we have this stream API in between us and a simple file? To answer that, lets consider this scenario:

    Imagine we have a file that is 10Gb long. If we ask for that file and the OS just gives that to us, it means our RAM will have to allocate memory for 10Gb of continuous space all of a sudden just to fit in one single file. Not only that but also computing power will be necessary in order for the PC to write all of those 10GB of data from the disk onto the RAM. Can you imagine stopping all processes until you are done loading 10GBs of RAM? (assuming its not multithreaded code). Thats a nono in user-experience-land. So, instead of that we have this concept of data streams, which act as these tunnels that connect the data in the disk with your application.

The way data streams work is by allowing you to ask them for X ammount of data (this can be of any size you want). When you ask for X bytes or Y bytes of data, the data stream object will go to where the data is (rather, it will ask the OS for it), take that ammount and send it to you in order, after which it will keep track of how much data you asked it for, so that next time you ask for more it can start continue serving you data from where it left off last time.

This means that if a file contains these bytes of data:

**AF 2B 3C 45 CV**

And you ask for 2 bytes (why bytes? later), you will get:

**AF 2B**

Then, the next time you ask, you will get:

**3C 45**

And the pattern will continue until the data stream reaches the end of the file (known as EOF), at which point it will return NULL or EOF, or something along those lines depending on your API.

So if you think about this, you can already solve both of those problems we mentioned earlier (RAM size crisis and taking the CPU hostage for 10 years) by using this data stream concept:


    Imagine you are displaying a movie. That is easily 10GBs of data or more. By using streams, you could ask for one image at a time, display it, then ask for the next one and do that for the whole 10Gb. Now your smart tv with a USB connector doesnt need to have 10/20/30GBs of RAM to play a movie, let alone load it. Crappy 512MB are more than enough for any movie stored on your USB, no matter its length.


Now lets add buffers onto the mix, a buffer is simply a continuous space in memory that you have allocated to put some data in. That's it. Buffers come into play because usually when you are asking the stream for X or Y ammount of data, the way you do it is by passing a buffer to the stream to fill with data, so the size of the buffer determines the ammount of data you are asking for.


### Read, write, append:

Sometimes you want to edit a file, not just read its contents. For that you can use File modes.

Files modes are something that you must specify when creating a data string on a file because it affects the stream you get back. Lets go over the three most common files modes:

- **Read:** If you want to be able to read a file, you need to set its "read" file mode to true.
- **Write:** If you want to be able to write onto a file, you set the "write" file mode to true.

    Usually this means overriding the file's content. Meaning if your file contains the sentence "Hello World" and you write "Bye" onto it, your file contents will end up to be these: "Byelo World"

- **Append:** If you want to be able to add onto a file, you set the "append" file mode to true. Usually this means being able to write, starting at the end of the file, which means no overriding.

Depending on what you are using, you might be able to combine these modes (for example, read and write). This is all very API speciffic but the fact that there are file modes and they change what you can and cannot do with the data stream should be true for all languages, I/O libraries.

### Closing the stream:
A data stream is a connection between the file and your application. You must remember to close it after you are done with it to avoid corrupting your file or not applying your changes to it. This is what is called closing the file.


### Parsing

Data is always saved as binary, so when you get it from a file you need to know how to parse it back to what it is supposed to be.
When you know the data type and structure, you use an appropiate API that can parse it back.
When you dont you can only guess because there are no standard headers that all files must follow.

### Serialization

Whenever you want to save something onto a file, if its something complex you will have to serialize it before sending it up the stream. The reason is because files only store binary (because that's what the HDD/SDD disks store and what the computer works with).

Usually if you pass in text, it should be aotmatically converted into binary for you. But dont expect that same behaivor when trying to pass in object structures or the like. For those you need to serialize the data before saving it and to de-serialize it after retreving it.






